{"name":"Watched","tagline":"watched.js - Live, event driven dom element collections","body":"watched.js\r\n==========\r\n\r\nLive, event driven dom element collections \r\n\r\n- [Website](http://grmlin.github.io/watched/)\r\n- [Demo](http://grmlin.github.io/watched/demo.html)\r\n\r\n\r\n```javascript\r\n// give me nodelists\r\n\r\n// quick\r\nvar foos  = watched('.foo'); \r\n// or more specific\r\nvar foos2 = watched(document).querySelectorAll('.foo'); // same as watched('.foo')\r\nvar bars  = watched(document).querySelector('.bar');\r\nvar bazs  = watched(document).getElementsByClassName('.baz');\r\nvar links = watched(document).getElementsByTagName('a');\r\n\r\n// need the length\r\nvar linkcount = links.length;\r\n\r\n// access elements directly \r\nvar aLink = links[0];\r\n\r\n// or iterate\r\nfoos.forEach(function(element){\r\n  console.log(element);\r\n});\r\n\r\n// finally, stay up to date, when elements are added\r\nnodeList.on('added', function(addedElements){\r\n\tconsole.log(addedElements);\r\n});\r\n\r\n// removed\r\nnodeList.on('removed', function(removedElements){\r\n\tconsole.log(removedElements);\r\n});\r\n\r\n// or changed in general\r\nnodeList.on('changed', function(currentElements){\r\n\tconsole.log(currentElements);\r\n});\r\n```\r\n\r\n## Getting started\r\nInclude the latest build you can find inside the `dist` folder in your html.\r\n\r\n## How?\r\n\r\nBehind the scenes, **watched.js** uses the all new [`MutationObserver`](http://devdocs.io/dom/mutationobserver) to detect changes in the dom. [Browser support](http://caniuse.com/#feat=mutationobserver) is quite good these days.\r\n\r\nAn interval based fallback is included, so older browsers will profit, too. Anything >= IE9 should be fine.\r\n\r\nIn either case only a single mutation observer will be created for the scripts lifespan. All `LiveNodeList` instances will listens to this one observer. \r\n\r\n\r\n## Important notes\r\n\r\n- **The dom mutation listener is debounced!** That's why massive changes to the dom will happen in batches, not individually, and take some time. (20ms at the moment)\r\n\r\n- **Always use the ` added`, `removed` and `changed` events!** The node lists are live and bound to changes in the dom, but never called synchronously after the dom changed (see debouncing above). \r\n\r\n- **The fallback is slower than native!** It uses an intervall to scan for changes. It's not a good idea to do this too often, so the current timeout is set to 500ms. \r\n\r\n- **The magic might become expensive!** You better not use hundreds of live nodelists, they will all be updated and the queries re-evaluated in the background, when the dom changes!\r\n\r\n\r\n## API\r\n\r\n### watched\r\nThe globally available namespace. Can be used to either get a `LiveNodeList` directly or a decorated dom element to create lists with different queries by yourself.\r\n\r\n#### watched(selector) : [LiveNodeList](#livenodelist)\r\n\r\nShorthand to create a [`LiveNodeList`](#livenodelist) using `document` as the parent element and [`DomElement#querySelectorAll`](#domelementqueryselectorallselector--livenodelist).\r\n\r\n```javascript\r\nvar foos = watched('.foo');\r\n```\r\n\r\nthe same nodelist can be created with\r\n\r\n```javascript\r\nvar foos = watched(document).querySelectorAll('.foo');\r\n```\r\n\r\n##### selector\r\nType: `string`\r\n\r\nThe selector you would also use in [`DomElement#querySelectorAll`](#domelementqueryselectorallselector--livenodelist)\r\n\r\n\r\n##### returns\r\nType: [`LiveNodeList`](#livenodelist)\r\n\r\n#### watched(element) : [DomElement](#domelement)\r\n\r\nCreates the `DomElement` decorator we need.\r\n\r\n```javascript\r\nvar  el = watched(document);\r\n```\r\n\r\n##### element\r\nType: `HTMLElement`\r\n\r\nThe dom element you want to wrap.\r\n\r\n\r\n##### returns\r\nType: [`DomElement`](#domelement)\r\n\r\n### DomElement\r\n\r\nClass decorating native dom elements so it uses the internal `LiveNodeList`\r\n\r\n#### DomElement#querySelectorAll(selector) : [LiveNodeList](#livenodelist)\r\n\r\nSee [`querySelectorAll`](http://devdocs.io/dom/document.queryselectorall) for details.\r\n\r\n```javascript\r\nvar nodeList = watched(document).querySelectorAll('.foo');\r\n```\r\n\r\n#### DomElement#querySelector(selector) : [LiveNodeList](#livenodelist)\r\n\r\nSee [`querySelector`](http://devdocs.io/dom/document.queryselector) for details. The returned object will be always a `LiveNodeList`, not a single element as in the native `querySelector`.\r\n\r\n```javascript\r\nvar nodeList = watched(document).querySelector('.foo');\r\n```\r\n\r\n\r\n#### DomElement#getElementsByTagName(selector) : [LiveNodeList](#livenodelist)\r\n\r\nSee [`getElementsByTagName`](http://devdocs.io/dom/element.getelementsbytagname) for details. Should be faster than the query selectors, as **watched.js** uses the native live nodelist internally to get the elements you want.\r\n\r\n```javascript\r\nvar nodeList = watched(document).getElementsByTagName('a');\r\n```\r\n\r\n\r\n#### DomElement#getElementsByClassName(selector) : [LiveNodeList](#livenodelist)\r\n\r\nSee [`getElementsByClassName`](http://devdocs.io/dom/document.getelementsbyclassname) for details. Should be faster than the query selectors, as **watched.js** uses the native live nodelist internally to get the elements you want.\r\n\r\n```javascript\r\nvar nodeList = watched(document).getElementsByClassName('.foo');\r\n```\r\n\r\n\r\n### LiveNodeList\r\n\r\nA list of dom elements, always up to date. It's \"array-like\", similar to jquery objects or native node lists.\r\n\r\n- live list, similar to the list returned by `getElementsBy(Tag|Class)Name`\r\n- dispatches event, if the list changed!\r\n\r\n#### LiveNodeList#length\r\n\r\nCurrent length of the nodelist\r\n\r\n#### LiveNodeList#on(eventName, callback)\r\n\r\nAdds an event listener\r\n\r\n##### eventName\r\nType: `string`\r\n\r\nsee [events](#livenodelist.events) for available event types\r\n\r\n#### callback\r\nType: `function`\r\n\r\n#### LiveNodeList#off(eventName, callback)\r\n\r\nRemoves an event listener\r\n\r\n##### eventName\r\nType: `string`\r\n\r\nsee [events](#livenodelist.events) for available event types\r\n\r\n#### callback\r\nType: `function`\r\n\r\n\r\n#### LiveNodeList#forEach(callback)\r\n\r\nsee the native [`Array.forEach`](http://devdocs.io/javascript/global_objects/array/foreach) for details.\r\n\r\n```javascript\r\nnodeList.forEach(function(element){\r\n\telement.style.color = \"green\";\r\n});\r\n```\r\n\r\n#### LiveNodeList#pause()\r\n\r\nFreezes the nodelist in it's current form and removes the dom mutation listener\r\n\r\n```javascript\r\nnodeList.pause();\r\n```\r\n\r\n#### LiveNodeList#resume()\r\n\r\nResumes all dom mutation listeners and will update the nodelist, if it changes\r\n\r\n```javascript\r\nnodeList.resume();\r\n```\r\n\r\n#### LiveNodeList.Events\r\n\r\n#### \"changed\"\r\n\r\nEvent called when new elements are added to or removed from the dom\r\n\r\n```javascript\r\nnodeList.on('changed', function(currentElements){\r\n\tconsole.log(currentElements);\r\n});\r\n```\r\n\r\nThe event listeners callback will be called with one argument: an array containing all elements currently in the list\r\n\r\n#### \"added\"\r\nEvent called when new elements are added to the dom\r\n\r\n```javascript\r\nnodeList.on('added', function(newElements){\r\n\tconsole.log(newElements);\r\n});\r\n```\r\n\r\nThe event listeners callback will be called with one argument: an array containing the newly found dom elements\r\n\r\n#### \"removed\"\r\n\r\nEvent called when elements are removed from the dom\r\n\r\n```javascript\r\nnodeList.on('removed', function(removedElements){\r\n\tconsole.log(removedElements);\r\n});\r\n```\r\n\r\nThe event listeners callback will be called with one argument: an array `removedElements` containing the dom elements removed from the list (removed from the dom)\r\n\r\n\r\n## Thanks\r\n\r\n- [DECAF](http://decaf.de/)\r\n- [smokesignals.js](https://bitbucket.org/bentomas/smokesignals.js/) - used as event emitter\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}